/*
Прыжки по буквам.
Дана цепочка из N символов, состоящая из прописных английских букв.
Необходимо пройти с первого символа цепочки до последнего символа, прыгая не более чем на K символов.
Стоимость прыжка, при котором символ не меняется, равна 0, а стоимость прыжка на другой символ равна 1.
Пример: "ABABBCACBC" можно пройти в цену 2 (A-B-B-C-C-C) при к=2.
Реализовать функцию «int hopcost(char *str, int k)»,
которая принимает входную последовательность и длину прыжка k и возвращает цену перехода.
Длина входной последовательности не больше 200 символов.
*/

#include <stdio.h>

int hopcost(char *s, int k)
{
    int a['Z'-'A'+1],               //суммы шагов с шагающей буквы
        b['Z'-'A'+1] = {0},         //последние места букв
        st = s[0]-'A',              //текущая буква
        s0 = st,                    //перво-рассматриваемая/оптимальная буква
        end;                        //последне-рассмотренная буква
    for(int i = 0; i <= 'Z'-'A'; ++i) a[i] = 2147483647;
    for(int i = 1; i <= k; i++)
    {
        st = s[i]-'A';
        if(s0 == st) a[st] = 0;
        else a[st] = 1;
        b[st] = i;
        end = st;
    }
    for(int i = k+1; s[i]; ++i)
    {
        st = s[i]-'A';
        s0 = st;
        int min_a = a[st];
        for(int j=0; j <= 'Z'-'A'; ++j)
            if(a[j] < min_a)
            {
                min_a = a[j];
                s0 = j;
            }
        if(st != s0) ++min_a;
        a[st] = min_a;
        b[st] = i;
        for(int j=0; j <= 'Z'-'A'; ++j)
            if(b[j]+k == i)
            {
                b[j] = 0;
                a[j] = 2147483647;
            }
        end = st;
    }
    return a[end];
}

int main()
{
    int k = 3;                                      //max размер прыжка
    char *s = "ABCDDBBCCADEACBABCABBACCADEA";       //входная цепочка символов
    printf("%d\n", hopcost(s, k));
    return 0;
}