/*
Звездные прямоугольники.
На декартовой плоскости заданы N вершин с целочисленными координатам.
Любые 4 вершины, которые можно соединить вертикальными и горизонтальными линиями, образуют прямоугольник.
Посчитать, сколько прямоугольников можно составить из данных N вершин.
Прямоугольники нулевой площади не считаются.
Например, из точек (0,0) (0,1) (1,0) (1,1) (2,0) (2,1) (3,0) можно составить 3 прямоугольника.
Сколько можно составить прямоугольников, если к этим точкам добавить точку (3,1)?
*/

#include <stdio.h>

int equality(int a1, int a2, int a3, int a4)    //определение наличия повторяющихся значений
{
    int a[4] = {a1, a2, a3, a4},
        s = 0;                                  //счётчик совпадений
    for(int i = 0; i < 3; ++i)
        for(int j = i+1; j < 4; ++j)
            s = a[i] == a[j] ? s+1 : s;
    return s;
}

int main()
{
    int x[] = {0, 0, 1, 1, 2, 2, 3, 3},         //значения абсцисс
        y[] = {0, 1, 0, 1, 0, 1, 0, 1},         //значения ординат, в соответствиями со значениями абсцисс
        n = sizeof(x) / sizeof(x[0]),           //кол-во заданных точек
        p = 0;                                  //кол-во возможных прямоугольников
    for(int i = 0; i < n; ++i)
        for(int j = 0; j < n; ++j)
            for(int k = 0; k < n; ++k)
                for(int l = 0; l < n; ++l)
                    if(!equality(i, j, k, l))
                        p = ((x[j]-x[i])*(x[k]-x[j]) + (y[j]-y[i])*(y[k]-y[j])) ||          //Определение прямоугольника
                            ((x[k]-x[j])*(x[l]-x[k]) + (y[k]-y[j])*(y[l]-y[k])) ||          //исходя из скалярных
                            ((x[l]-x[k])*(x[i]-x[l]) + (y[l]-y[k])*(y[i]-y[l])) ||          //произведений направляющих
                            ((x[i]-x[l])*(x[j]-x[i]) + (y[i]-y[l])*(y[j]-y[i])) ? p : p+1;  //векторов его сторон
    printf("%d\n",p/8);
    return 0;
}
